{
  "hash": "68f4d03685a8d920f57f34b601add75a",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"rix: environnements de développement reproductibles pour développeurs R\"\nauthor: \"Bruno Rodrigues\"\nformat:\n  revealjs:\n    embed-resources: true\n    slide-number: true\n    theme: solarized\n    incremental: true\nexecute:\n  echo: true\n---\n\n\n## Qui suis-je?\n\n- Bruno Rodrigues, responsable des départements \"statistiques\" et \"stratégie de données\" du Ministère \n  de la Recherche et de l’Enseignement supérieur au Luxembourg\n\n- Utilisateur de R depuis 2009\n\n- Cette présentation est disponible sur le lien suivant [https://is.gd/nix_russ](https://is.gd/nix_russ)\n\n- Code source disponible ici: [https://github.com/b-rodrigues/russ_workshop](https://github.com/b-rodrigues/russ_workshop)\n\n## But de cet atelier\n\n- Apprendre juste ce qu'il faut de Nix pour \"être dangereux\"\n- Programme:\n\n    * C'est quoi Nix?\n    * Le problème que Nix résoud\n    * Le *gestionnaire de paquets fonctionnel*\n    * Le langage Nix\n    * rix, ou comment utiliser Nix facilement\n\n- Si le temps le permet: créer son propre cache de binaires avec [Cachix](https://www.cachix.org/)\n\n## C'est quoi Nix ? (1/2)\n\n- Un gestionnaire de paquets\n- Un langage de programmation\n- Une distribution Linux ([NixOS](https://nixos.org/))\n\n. . .\n\nLe sujet d'aujourd'hui: le gestionnaire de paquets\n\n## C'est quoi Nix ? (2/2)\n\n- Nix est un outil complexe\n\n- Il faut de l'investissement de la part des utilisateurs\n\n- Mais `{rix}` va nous aider!\n\n## Le gestionnaire de paquets Nix\n\n- Gestionnaire de paquets: un outil pour administrer des ...paquets\n\n- Paquet: n'importe quel logiciel (pas seulement des paquets R)\n\n- Voici un gestionnaire de paquets populaire:\n\n## Le gestionnaire de paquets Nix\n\n![Google Play Store](img/play_store.png)\n\n## Le problème que Nix résoud (1/3)\n\n- La promesse de Nix:\n\n. . .\n\n*Installe tous les logiciels nécessaires (R, paquets R, librairies de développement,\netc) de manière totalement reproductible et sur n'importe quelle plate-forme en écrivant\nune seule expression dans le langage Nix.*\n\n## Le problème que Nix résoud (2/3)\n\n- Comment retrouver la même chose sans Nix?\n\n. . .\n\n- Il faut figer R avec le [R Installation Manager](https://github.com/r-lib/rig)\n- Il faut figer les paquets R avec `{renv}`\n- Il faut figer **toutes** les autres dépendances *invisibles*, idéalement avec Docker\n\n. . .\n\n(Remarque: on peut s'abstraire de `rig` si Docker inclut la bonne version de R)\n\n. . .\n\nNix permet de tout gérer d'un seul coup!\n\n## Le problème que Nix résoud (3/3)\n\n- Sans Nix (ou Docker + `{renv}`) on doit accepter les risques suivants:\n\n    * Collaborateurs travaillent sur des environnements hétérogènes (*ça marche chez mwaaaaaaaa!!!*)\n    * Les analyses produites ne sont (très probablement) pas reproductibles\n\n- Une vraie bombe à retardement\n\n## Le *gestionnaire de paquets fonctionnel* (1/3)\n\n- Nix est un gestionnaire de paquets *fonctionnel*\n\n- *Fonctionnel*, comme la programmation fonctionnelle inspirée du lambda-calcul\n\n- Lambda-calcul? Pour faire simple:\n\n. . .\n\n-> f(x)=y\n\n- f(x) va **toujours** donner y\n\n- Autrement dit, y ne dépend de rien d'autre que de x qui est transformé par f\n\n## Le *gestionnaire de paquets fonctionnel* (2/3)\n\n> The idea is to always deploy component closures: if we deploy a component,\n> then we must also deploy its dependencies, their dependencies, and so on. That\n> is, we must always deploy a set of components that is closed under the\n> ''depends on'' relation. Since closures are selfcontained, they are the units\n> of complete software deployment. After all, if a set of components is not\n> closed, it is not safe to deploy, since using them might cause other\n> components to be referenced that are missing on the target system.\n\n<p style=\"font-size: x-large\">Eelco Dolstra, *Nix: A Safe and Policy-Free System for Software Deployment*</p>\n\n## Le *gestionnaire de paquets fonctionnel* (3/3)\n\n- Par exemple: `install.packages(\"dplyr\")` ne va pas toujours donner le même résultat!\n- Quelle est la variable *cachée*?\n\n## Le *gestionnaire de paquets fonctionnel* (3/3)\n\n![Attention aux effets de bord!](img/procedural_vs_fonctional.png)\n\n## Le langage Nix (1/6)\n\n```\nlet\n  pkgs = import (fetchTarball \"https://github.com/NixOS/nixpkgs/archive/976fa3369d722e76f37c77493d99829540d43845.tar.gz\") {};\n  system_packages = builtins.attrValues {\n    inherit (pkgs) R ;\n  };\nin\n  pkgs.mkShell {\n    buildInputs = [ system_packages ];\n    shellHook = \"R --vanilla\";\n  }\n```\n\n## Le langage Nix (2/6)\n\n- Défini le dépôt à utiliser (avec un commit figé)\n- Liste les paquets à installer\n- Défini ce qui doit être construit: un *shell*\n\n## Le langage Nix (3/6)\n\n- Les paquets Nix sont tous téléchargés depuis un mono-dépôt gigantesque sur Github\n- Github: reproductibilité assurée via les commits!\n- Par exemple, ce commit installera R 4.3.1 et les paquets associés:\n\n. . .\n\n```\npkgs = import (fetchTarball \"https://github.com/NixOS/nixpkgs/archive/976fa3369d722e76f37c77493d99829540d43845.tar.gz\") {};\n```\n\n- Jettons-y un œil [liens vers nixpkgs](https://github.com/NixOS/nixpkgs)...\n\n## Le langage Nix (4/6)\n\n- `system_packages`: une variable qui liste les paquets à installer\n- Ici, seulement R:\n\n. . .\n\n```\nsystem_packages = builtins.attrValues {\n  inherit (pkgs) R ;\n};\n```\n\n## Le langage Nix (5/6)\n\n- Finalement, on définit un *shell*:\n\n. . .\n\n```\npkgs.mkShell {\n  buildInputs = [ system_packages ];\n  shellHook = \"R --vanilla\";\n}\n```\n\n. . .\n\n- Ce shell inclura les paquets définis dans `system_packages` (`buildInputs`)\n- Et va lancer `R --vanilla` au démarrage (`shellHook`)\n\n## Le langage Nix (6/6)\n\n- Écrire ces expressions nécessite l'apprentissage d'une nouveau langage\n- Un langage puissant certes... mais si tout ce qu'on veut c'est des environnements de développement reproductibles...\n- ...alors `{rix}` est la solution!\n\n## Les expressions Nix\n\n- Les expressions Nix sont utilisées pour installer des logiciels\n- Nous allons les utiliser pour avoir des shells spécifiques à des projets\n- R, LaTeX, Quarto, Julia... +80'000 paquets disponibles\n- Nix va s'occuper d'installer et gérer toutes les dépendances!\n\n## CRAN et Bioconductor\n\n- Presque tous les paquets CRAN et Biocondcutor sont disponibles (+23'000)\n- Cherchez les paquets [ici](https://search.nixos.org/packages?channel=23.11&from=0&size=50&sort=relevance&type=packages&query=dplyr)\n\n## Intro à rix (1/4)\n\n- `{rix}` ([site](https://b-rodrigues.github.io/rix/index.html)) génère des expressions Nix!\n- Il suffit d'utiliser la fonction `rix()`:\n\n. . .\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(rix)\n\nrix(r_ver = \"4.3.1\",\n    r_pkgs = c(\"dplyr\", \"ggplot2\"),\n    system_pkgs = NULL,\n    git_pkgs = NULL,\n    tex_pkgs = NULL,\n    ide = \"rstudio\",\n    # This shellHook is required to run Rstudio on Linux\n    # you can ignore it on other systems\n    shell_hook = \"export QT_XCB_GL_INTEGRATION=none\",\n    project_path = \".\")\n```\n:::\n\n\n## Intro à rix (2/4)\n\n- Listez la version de R et les paquets\n- Optionellement: d'autres paquets (logiciels), ou des paquets R sur Github, des paquets LaTeX\n- Optionellement: une interface de développement (Rstudio, Radian, VS Code ou \"other\")\n- Vous pourrez travailler interactivement ou non!\n\n## Intro à rix (3/4)\n\n- `rix::rix()` génère un fichier `default.nix`\n- Utilisez `nix-build` (dans le terminal) ou `rix::nix_build()` depuis R pour installer le shell défini dans `default.nix`\n- Démarrez le shell avec `nix-shell`\n- Il est possible de générer des expressions même si Nix n’est pas installé\n\n## Intro à rix (4/4)\n\n- Possible d'installer des versions spécifiques (syntaxe: `\"dplyr@1.0.0\"`)\n- Ou des paquets seulement dispos sur Github\n- Beaucoup de documentation [disponible](https://b-rodrigues.github.io/rix/articles/)\n\n. . .\n\nJettons un coup d'œil à `expressions/rix_intro/` maintenant...\n\n## Utilisation \"non-interactive\"\n\n- `{rix}` rend possible d’exécuter des pipelines dans le bon environnement\n- (Petite parenthèse: le meilleur paquet pour créer des pipelines avec R est `{targets}`)\n- Regardons `expressions/nix_targets_pipeline`\n- Aussi possible d'exécuter la pipeline sans devoir d’abord entrer dans le shell:\n\n. . .\n\n```\ncd /absolute/path/to/pipeline/ && nix-shell default.nix --run \"Rscript -e 'targets::tar_make()'\"\n```\n\n## Nix et Github Actions: lancer une pipeline\n\n- Simple d’exécuter une pipeline `{targets}` dans Github actions\n- Lancez `rix::tar_nix_ga()` pour générer les fichiers nécessaires\n- Committez et poussez, et regardez la pipeline tourner sur GA!\n- [Voir ici](https://github.com/b-rodrigues/nix_targets_pipeline/tree/master).\n\n## Nix et Github Actions: écrire des documents\n\n- Possible de collaborer sur des documents aussi\n- Regardez ici [here](https://github.com/b-rodrigues/rix_paper/tree/master)\n- Concentrez-vous sur l’écriture!\n\n## Subshells\n\n- Il est aussi possible d’exécuter une seule commande depuis un \"subshell\"\n- Fonctionne depuis un R installé \"traditionnellement\" ou via Nix\n- Utile dans le cas où on a besoin d’un paquet difficile à installer, comme {arrow} (dans certains cas)\n- Regardons `expressions/subshell`\n\n## Cycle de publication des paquets R pour Nix\n\n- CRAN est mis à jour quotidiennement, mais ce n’est pas le cas sur `nixpkgs`\n- L'ensemble `rPackages` est mis à jour avec une nouvelle sortie de R (tous les 3 mois grosso modo)\n- \"Mais si j’ai besoin de paquets à jour?\"\n- Une solution: utilisez notre fork de  `nixpkgs`: `rstats-on-nix` [ici](https://github.com/rstats-on-nix/nixpkgs/tree/r-daily)!\n\n## Paquets quotidiennement mis à jour (1/2)\n\n- Pour utiliser notre fork, utilisez \"bleeding_edge\" ou \"frozen_edge\":\n\n. . .\n\n```\nrix(r_ver = \"bleeding_edge\",\n    r_pkgs = c(\"dplyr\", \"ggplot2\"),\n    ...\n}\n```\n\n- \"bleeding_edge\": génère un environnement frais à chaque build\n- \"frozen_edge\": génère un environnement frais au premier build, figé par la suite\n\n## Paquets quotidiennement mis à jour (2/2)\n\n- Problème: tous les paquets doivent être compilés\n- Solution: utilisez notre Cache de paquets binaires :)\n- La vignette [\"bleeding edge\"](https://b-rodrigues.github.io/rix/articles/z-bleeding_edge.html) explique tout ça!\n- Possible aussi de configurer [votre propre cache](https://b-rodrigues.github.io/rix/articles/z-binary_cache.html)\n\n## Pour en apprendre plus\n\n- Documentation officielle de Nix: [https://nix.dev/](https://nix.dev/)\n\n- Nix pills: [https://nixos.org/guides/nix-pills/00-preface](https://nixos.org/guides/nix-pills/00-preface)\n\n- Tuto Nix par l'INRIA: [https://nix-tutorial.gitlabpages.inria.fr/nix-tutorial/](https://nix-tutorial.gitlabpages.inria.fr/nix-tutorial/)\n\n- Mon blog: [https://b-rodrigues.github.io/rix/](https://b-rodrigues.github.io/rix/)\n\n- Mon livre (ne parle pas de Nix, mais de reproductibilité avec Docker et renv): [https://raps-with-r.dev/](https://raps-with-r.dev/)\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}