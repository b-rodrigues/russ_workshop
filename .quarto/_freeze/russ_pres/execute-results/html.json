{
  "hash": "866a6316fe6195590b59d11ddff79552",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"rix: environnements de développement reproductibles pour développeurs R\"\nauthor: \"Bruno Rodrigues\"\nformat:\n  revealjs:\n    embed-resources: true\n    slide-number: true\n    theme: solarized\n    incremental: true\nexecute:\n  echo: true\n---\n\n\n## Qui suis-je?\n\n- Bruno Rodrigues, responsable des départements \"statistiques\" et \"stratégie de données\" du Ministère \n  de la Recherche et de l’Enseignement supérieur au Luxembourg\n\n- Utilisateur de R depuis 2009\n\n- Cette présentation est disponible sur le lien suivant [https://is.gd/nix_russ](https://is.gd/nix_russ)\n\n- Code available at: [https://github.com/b-rodrigues/russ_workshop](https://github.com/b-rodrigues/russ_workshop)\n\n## Goal of this workshop\n\n- Learn just enough of Nix to use it for your R projects\n- Show different use-cases\n- Time allowing: how to make your own binary cache using [Cachix](https://www.cachix.org/)\n\n## What is Nix? (1/2)\n\n- A package manager\n- A programming language\n- An operating system ([NixOS](https://nixos.org/))\n\n. . .\n\nOur focus today: the package manager\n\n## What is Nix? (2/2)\n\nA word of warning: Nix is quite complex\n\nIt does require some time to learn on the user's part\n\nBut `{rix}` will help\n\n## The Nix package manager\n\nPackage manager: tool to install and manage *packages*\n\nPackage: any piece of software (not just R packages)\n\nA popular package manager:\n\n## The Nix package manager\n\n![Google Play Store](img/play_store.png)\n\n## The reproducibility continuum\n\n- Make sure that the required/correct version of R (or any other language) is\n  installed;\n\n- Make sure that the required versions of packages are installed;\n\n- Make sure that system dependencies are installed (for example,\n  Java installation for rJava);\n\n- Make sure that you can install all of this for the hardware you have on hand.\n\n## Reproducibility in the R ecosystem\n\n- Per-project environments not often used\n- Popular choice: `{renv}`, but deals with R packages only\n- Still need to take care of R itself\n- System-level dependencies as well!\n\n. . .\n\nA popular approach: Docker + `{renv}` (see [Rocker project](https://rocker-project.org/))\n\n. . .\n\nNix deals with everything, with one single text file (called a Nix expression)!\n\n## \"Functional\" package manager (1/2)\n\n- Nix: a *functional* package manager\n\n- Functional, as in, inspired by mathematical functions\n\n- Why math functions?\n\n. . .\n\n-> f(x)=y\n\n- Building a Nix expression always results in the same output\n\n- Output doesn't depend on state of current system:\n\n## \"Functional\" package manager (2/2)\n\n> The idea is to always deploy component closures: if we deploy a component,\n> then we must also deploy its dependencies, their dependencies, and so on. That\n> is, we must always deploy a set of components that is closed under the\n> ''depends on'' relation. Since closures are selfcontained, they are the units\n> of complete software deployment. After all, if a set of components is not\n> closed, it is not safe to deploy, since using them might cause other\n> components to be referenced that are missing on the target system.\n\n<p style=\"font-size: x-large\">Eelco Dolstra, *Nix: A Safe and Policy-Free System for Software Deployment*</p>\n\n\n\n\n## A basic Nix expression (1/6)\n\n```\nlet\n  pkgs = import (fetchTarball \"https://github.com/NixOS/nixpkgs/archive/976fa3369d722e76f37c77493d99829540d43845.tar.gz\") {};\n  system_packages = builtins.attrValues {\n    inherit (pkgs) R ;\n  };\nin\n  pkgs.mkShell {\n    buildInputs = [ system_packages ];\n    shellHook = \"R --vanilla\";\n  }\n```\n\nThere's a lot to discuss here!\n\n## A basic Nix expression (2/6)\n\n- Written in the Nix language (not discussed)\n- Defines the repository to use (with a fixed revision)\n- Lists packages to install\n- Defines the output: a development shell\n\n## A basic Nix expression (3/6)\n\n- Software for Nix is defined as a mono-repository of tens of thousands of expressions on Github\n- Github: we can use any commit to pin package versions for reproducibility!\n- For example, the following commit installs R 4.3.1 and associated packages:\n\n. . .\n\n```\npkgs = import (fetchTarball \"https://github.com/NixOS/nixpkgs/archive/976fa3369d722e76f37c77493d99829540d43845.tar.gz\") {};\n```\n\n- Let's take a look at the [repository](https://github.com/NixOS/nixpkgs)...\n\n## A basic Nix expression (4/6)\n\n- `system_packages`: a variable that lists software to install\n- In this case, only R:\n\n. . .\n\n```\nsystem_packages = builtins.attrValues {\n  inherit (pkgs) R ;\n};\n```\n\n## A basic Nix expression (5/6)\n\n- Finally, we define a shell:\n\n. . .\n\n```\npkgs.mkShell {\n  buildInputs = [ system_packages ];\n  shellHook = \"R --vanilla\";\n}\n```\n\n. . .\n\n- This shell will come with the software defined in `system_packages` (`buildInputs`)\n- And launch `R --vanilla` when started (`shellHook`)\n\n## A basic Nix expression (6/6)\n\n- Writing these expressions requires learning a new language\n- While incredibly powerful, if all we want are per-project reproducible dev shells...\n- ...then `{rix}` will help!\n\n## Nix expressions\n\n- Nix expressions can be used to install software\n- But we will use them to build per-project development shells\n- We will include R, LaTeX packages, or Quarto, Python, Julia....\n- Nix takes care of installing every dependency down to the compiler!\n\n## CRAN and Bioconductor\n\n- CRAN is the repository of R packages to extend the language\n- As of writing, +20000 packages available\n- Biocondcutor: repository with a focus on Bioinformatics: +2000 more packages\n- Almost all available through `nixpkgs` in the `rPackages` set!\n- Find packages [here](https://search.nixos.org/packages?channel=23.11&from=0&size=50&sort=relevance&type=packages&query=dplyr)\n\n## rix: reproducible development environments with Nix (1/4)\n\n- `{rix}` ([website](https://b-rodrigues.github.io/rix/index.html)) makes writing Nix expression easy!\n- Simply use the provided `rix()` function:\n\n. . .\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(rix)\n\nrix(r_ver = \"4.3.1\",\n    r_pkgs = c(\"dplyr\", \"ggplot2\"),\n    system_pkgs = NULL,\n    git_pkgs = NULL,\n    tex_pkgs = NULL,\n    ide = \"rstudio\",\n    # This shellHook is required to run Rstudio on Linux\n    # you can ignore it on other systems\n    shell_hook = \"export QT_XCB_GL_INTEGRATION=none\",\n    project_path = \".\")\n```\n:::\n\n\n## rix: reproducible development environments with Nix (2/4)\n\n- List required R version and packages\n- Optionally: more system packages, packages hosted on Github, or LaTeX packages\n- Optionally: an IDE (Rstudio, Radian, VS Code or \"other\")\n- Work interactively in an isolated environment!\n\n## rix: reproducible development environments with Nix (3/4)\n\n- `rix::rix()` generates a `default.nix` file\n- Build expressions using `nix-build` (in terminal) or `rix::nix_build()` from R \n- \"Drop\" into the development environment using `nix-shell`\n- Expressions can be generated even without Nix installed\n\n## rix: reproducible development environments with Nix (4/4)\n\n- Can install specific versions of packages (write `\"dplyr@1.0.0\"`)\n- Can install packages hosted on Github\n- Many vignettes to get you started! [See here](https://b-rodrigues.github.io/rix/articles/)\n\n. . .\n\nLet's check out `expressions/rix_intro/`\n\n## Non-interactive use\n\n- `{rix}` makes it easy to run pipelines in the right environment\n- (Little side note: the best tool to build pipelines in R is `{targets}`)\n- See `expressions/nix_targets_pipeline`\n- Can also run the pipeline like so:\n\n. . .\n\n```\ncd /absolute/path/to/pipeline/ && nix-shell default.nix --run \"Rscript -e 'targets::tar_make()'\"\n```\n\n## Nix and Github Actions: running pipelines\n\n- Possible to easily run a `{targets}` pipeline on Github actions\n- Simply run `rix::tar_nix_ga()` to generate the required files\n- Commit and push, and watch the actions run!\n- See [here](https://github.com/b-rodrigues/nix_targets_pipeline/tree/master).\n\n## Nix and Github Actions: writing papers\n\n- Easy collaboration on papers as well\n- See [here](https://github.com/b-rodrigues/rix_paper/tree/master)\n- Just focus on writing!\n\n## Subshells\n\n- Also possible to evaluate single functions inside a \"subshell\"\n- Works from R installed via Nix or not!\n- Very useful to use hard-to-install packages such as {arrow}\n- See `expressions/subshell`\n\n## R packages release cycle\n\n- CRAN is updated daily, but it’s not reflected in nixpkgs\n- The `rPackages` set gets updated around new R releases (every 3 months or so)\n- What if more recent packages are required?\n- One solution: use our `nixpkgs` fork from our `rstats-on-nix` [organisation](https://github.com/rstats-on-nix/nixpkgs/tree/r-daily)!\n\n## Bleeding edge development environments (1/2)\n\n- To use our bleeding edge fork simply change the `pkgs` variable:\n\n. . .\n\n```\npkgs = import (fetchTarball \"https://github.com/rstats-on-nix/nixpkgs/archive/refs/heads/r-daily.tar.gz\") {};\n```\n\n- You can also use a specific commit of the fork instead:\n\n. . .\n\n```\npkgs = import (fetchTarball \"https://github.com/rstats-on-nix/nixpkgs/archive/78f705bd8689ad7d215f4b3aea9d9c1302a31b99.tar.gz\") {};\n```\n\n. . .\n\n- Will soon be supported in `{rix}`\n\n## Bleeding edge development environments (2/2)\n\n- But: everything needs to be built from source\n- Solution: roll out your own binary cache using [Cachix](https://www.cachix.org/)\n- Build the development environment on Github Actions\n- On your pc: install pre-compiled binaries!\n\n## To know more\n\n- Official Nix documentation: [https://nix.dev/](https://nix.dev/)\n\n- Nix pills: [https://nixos.org/guides/nix-pills/00-preface](https://nixos.org/guides/nix-pills/00-preface)\n\n- Nix tutorial by INRIA: [https://nix-tutorial.gitlabpages.inria.fr/nix-tutorial/](https://nix-tutorial.gitlabpages.inria.fr/nix-tutorial/)\n\n- My blog: [https://b-rodrigues.github.io/rix/](https://b-rodrigues.github.io/rix/)\n\n- My book (doesn't cover Nix, but Docker, `{renv}` and functional programming): [https://raps-with-r.dev/](https://raps-with-r.dev/)\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}