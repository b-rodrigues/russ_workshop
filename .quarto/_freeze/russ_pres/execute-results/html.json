{
  "hash": "a506680b020e3d468fb6d3b8abe23e40",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"rix: environnements de développement reproductibles pour développeurs R\"\nauthor: \"Bruno Rodrigues\"\nformat:\n  revealjs:\n    embed-resources: true\n    slide-number: true\n    theme: solarized\n    incremental: true\nexecute:\n  echo: true\n---\n\n\n## Qui suis-je?\n\n- Bruno Rodrigues, responsable des départements \"statistiques\" et \"stratégie de données\" du Ministère \n  de la Recherche et de l’Enseignement supérieur au Luxembourg\n\n- Utilisateur de R depuis 2009\n\n- Cette présentation est disponible sur le lien suivant [https://is.gd/nix_russ](https://is.gd/nix_russ)\n\n- Code source disponible ici: [https://github.com/b-rodrigues/russ_workshop](https://github.com/b-rodrigues/russ_workshop)\n\n## But de cet atelier\n\n- Apprendre juste ce qu'il faut de Nix pour \"être dangereux\"\n- Programme:\n\n. . .\n\n    * C'est quoi Nix?\n    * Le problème que Nix résoud\n    * Le *gestionnaire de paquets fonctionnel*\n    * Le langage Nix\n    * rix, ou comment utiliser Nix facilement\n\n. . .\n\n- Si le temps le permet: créer son propre cache de binaires avec [Cachix](https://www.cachix.org/)\n\n## C'est quoi Nix ? (1/2)\n\n- Un gestionnaire de paquets\n- Un langage de programmation\n- Une distribution Linux ([NixOS](https://nixos.org/))\n\n. . .\n\nLe sujet d'aujourd'hui: le gestionnaire de paquets\n\n## C'est quoi Nix ? (2/2)\n\n- Nix est un outil complexe\n\n- Il faut de l'investissement de la part des utilisateurs\n\n- Mais `{rix}` va nous aider!\n\n## Le gestionnaire de paquets Nix\n\n- Gestionnaire de paquets: un outil pour administrer des ...paquets\n\n- Paquet: n'importe quel logiciel (pas seulement des paquets R)\n\n- Voici un gestionnaire de paquets populaire:\n\n## Le gestionnaire de paquets Nix\n\n![Google Play Store](img/play_store.png)\n\n## Le problème que Nix résoud (1/3)\n\n- Proposition de valeur de Nix:\n\n. . .\n\n*Installe tous les logiciels nécessaires (R, paquets R, libraries de développement,\netc) de manière totalement reproductible et sur n'importe quelle plateforme en écrivant\nune seule expression dans le langage Nix.*\n\n## Le problème que Nix résoud (2/3)\n\n- Comment retrouver la même chose sans Nix?\n\n. . .\n\n- Il faut figer R avec le [R Installation Manager](https://github.com/r-lib/rig)\n- Il faut figer les paquets R avec `{renv}`\n- Il faut figer **toutes** les autres dépendances *invisibles*, idéalement avec Docker\n\n. . .\n\n(Remarque: on peut s'abstraire de `rig` si Docker inclut la bonne version de R)\n\n. . .\n\nNix permet de tout gérer d'un seul coup!\n\n## Le problème que Nix résoud (3/3)\n\n- Sans Nix (ou Docker + `{renv}`) on doit accepter les risques suivants:\n\n. . .\n\n    * Collaborateurs travaillent sur des environnements hétérogènes\n    * Les analyses produites ne sont (très probablement) pas reproductibles\n\n\n## Le *gestionnaire de paquets fonctionnel* (1/3)\n\n- Nix est un gestionnaire de paquets *fonctionnel*\n\n- *Fonctionnel*, comme la programmation fonctionnelle inspirée du lambda-calcul\n\n- Lambda-calcul? Pour faire simple:\n\n. . .\n\n-> f(x)=y\n\n- f(x) va **toujours** donner y\n\n- Autrement dit, y ne dépend de rien d'autre que de x qui est transformé par f\n\n## Le *gestionnaire de paquets fonctionnel* (2/3)\n\n> The idea is to always deploy component closures: if we deploy a component,\n> then we must also deploy its dependencies, their dependencies, and so on. That\n> is, we must always deploy a set of components that is closed under the\n> ''depends on'' relation. Since closures are selfcontained, they are the units\n> of complete software deployment. After all, if a set of components is not\n> closed, it is not safe to deploy, since using them might cause other\n> components to be referenced that are missing on the target system.\n\n<p style=\"font-size: x-large\">Eelco Dolstra, *Nix: A Safe and Policy-Free System for Software Deployment*</p>\n\n## Le *gestionnaire de paquets fonctionnel* (3/3)\n\n- Par exemple: `install.packages(\"dplyr\")` ne va pas toujours donner le même résultat!\n- Quelle est la variable *cachée*?\n\n## Le langage Nix (1/6)\n\n```\nlet\n  pkgs = import (fetchTarball \"https://github.com/NixOS/nixpkgs/archive/976fa3369d722e76f37c77493d99829540d43845.tar.gz\") {};\n  system_packages = builtins.attrValues {\n    inherit (pkgs) R ;\n  };\nin\n  pkgs.mkShell {\n    buildInputs = [ system_packages ];\n    shellHook = \"R --vanilla\";\n  }\n```\n\n## Le langage Nix (2/6)\n\n- Défini le dépôt à utiliser (avec un commit figé)\n- Liste les paquets à installer\n- Défini ce qui doit être construit: un *shell*\n\n## Le langage Nix (3/6)\n\n- Les paquets Nix sont tous téléchargés depuis un mono-dépôt gigantesque sur Github\n- Github: reproductibilité assurée via les commits!\n- Par exemple, ce commit installera R 4.3.1 et les paquets associés:\n\n. . .\n\n```\npkgs = import (fetchTarball \"https://github.com/NixOS/nixpkgs/archive/976fa3369d722e76f37c77493d99829540d43845.tar.gz\") {};\n```\n\n- Jettons-y un œil [liens vers nixpkgs](https://github.com/NixOS/nixpkgs)...\n\n## Le langage Nix (4/6)\n\n- `system_packages`: une variable qui liste les paquets à installer\n- Ici, seulement R:\n\n. . .\n\n```\nsystem_packages = builtins.attrValues {\n  inherit (pkgs) R ;\n};\n```\n\n## Le langage Nix (5/6)\n\n- Finalement, on définit un *shell*:\n\n. . .\n\n```\npkgs.mkShell {\n  buildInputs = [ system_packages ];\n  shellHook = \"R --vanilla\";\n}\n```\n\n. . .\n\n- Ce shell inclura les paquets définis dans `system_packages` (`buildInputs`)\n- Et va lancer `R --vanilla` au démarrage (`shellHook`)\n\n## Le langage Nix (6/6)\n\n- Écrire ces expressions nécessite l'apprentissage d'une nouveau langage\n- Un langage puissant certes... mais si tout ce qu'on veut c'est des environnements de développement reproductibles...\n- ...alors `{rix}` est la solution!\n\n## Les expressions Nix\n\n- Les expressions Nix sont utilisées pour installer des logiciels\n- Nous allons les utiliser pour avoir des shells spécifiques à des projets\n- R, LaTeX, Quarto, Julia... +80'000 paquets disponibles\n- Nix va s'occuper d'installer et gérer toutes les dépendances!\n\n## CRAN et Bioconductor\n\n- Presque tous les paquets CRAN et Biocondcutor sont disponibles (+23'000)\n- Cherchez les paquets [ici](https://search.nixos.org/packages?channel=23.11&from=0&size=50&sort=relevance&type=packages&query=dplyr)\n\n## Intro à rix (1/4)\n\n- `{rix}` ([site](https://b-rodrigues.github.io/rix/index.html)) génère des expressions Nix!\n- Il suffit d'utiliser la fonction `rix()`:\n\n. . .\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(rix)\n\nrix(r_ver = \"4.3.1\",\n    r_pkgs = c(\"dplyr\", \"ggplot2\"),\n    system_pkgs = NULL,\n    git_pkgs = NULL,\n    tex_pkgs = NULL,\n    ide = \"rstudio\",\n    # This shellHook is required to run Rstudio on Linux\n    # you can ignore it on other systems\n    shell_hook = \"export QT_XCB_GL_INTEGRATION=none\",\n    project_path = \".\")\n```\n:::\n\n\n## Intro à rix (2/4)\n\n- Listez la version de R et les paquets\n- Optionellement: d'autres paquets (logiciels), ou des paquets R sur Github, des paquets LaTeX\n- Optionellement: une interface de développement (Rstudio, Radian, VS Code ou \"other\")\n- Vous pourrez travailler interactivement ou non!\n\n## rix: reproducible development environments with Nix (3/4)\n\n- `rix::rix()` generates a `default.nix` file\n- Build expressions using `nix-build` (in terminal) or `rix::nix_build()` from R \n- \"Drop\" into the development environment using `nix-shell`\n- Expressions can be generated even without Nix installed\n\n## rix: reproducible development environments with Nix (4/4)\n\n- Can install specific versions of packages (write `\"dplyr@1.0.0\"`)\n- Can install packages hosted on Github\n- Many vignettes to get you started! [See here](https://b-rodrigues.github.io/rix/articles/)\n\n. . .\n\nLet's check out `expressions/rix_intro/`\n\n## Non-interactive use\n\n- `{rix}` makes it easy to run pipelines in the right environment\n- (Little side note: the best tool to build pipelines in R is `{targets}`)\n- See `expressions/nix_targets_pipeline`\n- Can also run the pipeline like so:\n\n. . .\n\n```\ncd /absolute/path/to/pipeline/ && nix-shell default.nix --run \"Rscript -e 'targets::tar_make()'\"\n```\n\n## Nix and Github Actions: running pipelines\n\n- Possible to easily run a `{targets}` pipeline on Github actions\n- Simply run `rix::tar_nix_ga()` to generate the required files\n- Commit and push, and watch the actions run!\n- See [here](https://github.com/b-rodrigues/nix_targets_pipeline/tree/master).\n\n## Nix and Github Actions: writing papers\n\n- Easy collaboration on papers as well\n- See [here](https://github.com/b-rodrigues/rix_paper/tree/master)\n- Just focus on writing!\n\n## Subshells\n\n- Also possible to evaluate single functions inside a \"subshell\"\n- Works from R installed via Nix or not!\n- Very useful to use hard-to-install packages such as {arrow}\n- See `expressions/subshell`\n\n## R packages release cycle\n\n- CRAN is updated daily, but it’s not reflected in nixpkgs\n- The `rPackages` set gets updated around new R releases (every 3 months or so)\n- What if more recent packages are required?\n- One solution: use our `nixpkgs` fork from our `rstats-on-nix` [organisation](https://github.com/rstats-on-nix/nixpkgs/tree/r-daily)!\n\n## Bleeding edge development environments (1/2)\n\n- To use our bleeding edge fork simply change the `pkgs` variable:\n\n. . .\n\n```\npkgs = import (fetchTarball \"https://github.com/rstats-on-nix/nixpkgs/archive/refs/heads/r-daily.tar.gz\") {};\n```\n\n- You can also use a specific commit of the fork instead:\n\n. . .\n\n```\npkgs = import (fetchTarball \"https://github.com/rstats-on-nix/nixpkgs/archive/78f705bd8689ad7d215f4b3aea9d9c1302a31b99.tar.gz\") {};\n```\n\n. . .\n\n- Will soon be supported in `{rix}`\n\n## Bleeding edge development environments (2/2)\n\n- But: everything needs to be built from source\n- Solution: roll out your own binary cache using [Cachix](https://www.cachix.org/)\n- Build the development environment on Github Actions\n- On your pc: install pre-compiled binaries!\n\n## To know more\n\n- Official Nix documentation: [https://nix.dev/](https://nix.dev/)\n\n- Nix pills: [https://nixos.org/guides/nix-pills/00-preface](https://nixos.org/guides/nix-pills/00-preface)\n\n- Nix tutorial by INRIA: [https://nix-tutorial.gitlabpages.inria.fr/nix-tutorial/](https://nix-tutorial.gitlabpages.inria.fr/nix-tutorial/)\n\n- My blog: [https://b-rodrigues.github.io/rix/](https://b-rodrigues.github.io/rix/)\n\n- My book (doesn't cover Nix, but Docker, `{renv}` and functional programming): [https://raps-with-r.dev/](https://raps-with-r.dev/)\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}